"""
Zero-Knowledge Proof Verifier
Verifies proofs generated by Noir circuits
"""

import os
import json
import subprocess
import hashlib
from typing import Dict, Any, Optional, List


class NoirProofVerifier:
    """Verifies zero-knowledge proofs using Noir circuits"""
    
    def __init__(self, circuits_dir: str = "zkp/circuits"):
        self.circuits_dir = circuits_dir
        self.noir_available = self._check_noir_installation()
        
    def _check_noir_installation(self) -> bool:
        """Check if Noir is installed and available"""
        try:
            result = subprocess.run(['nargo', '--version'], 
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
    
    def verify_access_permission_proof(self, proof: str, public_inputs: Dict[str, Any], 
                                     sample_id: str) -> Dict[str, Any]:
        """Verify access permission proof"""
        try:
            if not self.noir_available:
                return self._simulate_access_verification(proof, public_inputs, sample_id)
            
            # Execute Noir verification
            verification_result = self._execute_noir_verify("prove_access_permission", proof, public_inputs)
            
            if verification_result['success']:
                # Additional validation
                validation_result = self._validate_access_inputs(public_inputs, sample_id)
                
                return {
                    'success': True,
                    'valid': verification_result['valid'] and validation_result['valid'],
                    'circuit_type': 'access_permission',
                    'sample_id': sample_id,
                    'verification_details': {
                        'noir_verification': verification_result['valid'],
                        'input_validation': validation_result['valid'],
                        'validation_message': validation_result.get('message', '')
                    }
                }
            else:
                return {
                    'success': False,
                    'error': verification_result['error']
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Proof verification failed: {str(e)}'
            }
    
    def verify_identity_proof(self, proof: str, public_inputs: Dict[str, Any], 
                            challenge: str) -> Dict[str, Any]:
        """Verify identity proof"""
        try:
            if not self.noir_available:
                return self._simulate_identity_verification(proof, public_inputs, challenge)
            
            # Execute Noir verification
            verification_result = self._execute_noir_verify("verify_identity", proof, public_inputs)
            
            if verification_result['success']:
                # Additional validation
                validation_result = self._validate_identity_inputs(public_inputs, challenge)
                
                return {
                    'success': True,
                    'valid': verification_result['valid'] and validation_result['valid'],
                    'circuit_type': 'identity_verification',
                    'challenge': challenge,
                    'verification_details': {
                        'noir_verification': verification_result['valid'],
                        'input_validation': validation_result['valid'],
                        'validation_message': validation_result.get('message', '')
                    }
                }
            else:
                return {
                    'success': False,
                    'error': verification_result['error']
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Identity proof verification failed: {str(e)}'
            }
    
    def _execute_noir_verify(self, circuit_name: str, proof: str, 
                           public_inputs: Dict[str, Any]) -> Dict[str, Any]:
        """Execute Noir proof verification"""
        try:
            circuit_path = os.path.join(self.circuits_dir, circuit_name)
            
            # Create Verifier.toml file
            verifier_toml = self._create_verifier_toml(public_inputs)
            verifier_path = os.path.join(circuit_path, "Verifier.toml")
            
            with open(verifier_path, 'w') as f:
                f.write(verifier_toml)
            
            # Write proof file
            proof_path = os.path.join(circuit_path, "proofs", "proof.proof")
            os.makedirs(os.path.dirname(proof_path), exist_ok=True)
            
            with open(proof_path, 'w') as f:
                f.write(proof)
            
            # Execute nargo verify
            result = subprocess.run(
                ['nargo', 'verify'],
                cwd=circuit_path,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                return {
                    'success': True,
                    'valid': True
                }
            else:
                return {
                    'success': True,
                    'valid': False,
                    'error': f'Verification failed: {result.stderr}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'Noir verification failed: {str(e)}'
            }
    
    def _create_verifier_toml(self, public_inputs: Dict[str, Any]) -> str:
        """Create Verifier.toml file for Noir circuit"""
        toml_content = []
        
        for key, value in public_inputs.items():
            toml_content.append(f'{key} = "{value}"')
        
        return '\n'.join(toml_content)
    
    def _validate_access_inputs(self, public_inputs: Dict[str, Any], 
                              sample_id: str) -> Dict[str, Any]:
        """Validate access permission inputs"""
        try:
            required_fields = ['sample_id', 'permission_hash', 'timestamp']
            
            # Check required fields
            for field in required_fields:
                if field not in public_inputs:
                    return {
                        'valid': False,
                        'message': f'Missing required field: {field}'
                    }
            
            # Validate timestamp (not too old or in future)
            import time
            current_time = int(time.time())
            proof_timestamp = int(public_inputs['timestamp'])
            
            # Allow 1 hour tolerance
            if abs(current_time - proof_timestamp) > 3600:
                return {
                    'valid': False,
                    'message': 'Proof timestamp is too old or in future'
                }
            
            # Validate field formats (should be numeric strings)
            for field in required_fields:
                try:
                    int(public_inputs[field])
                except ValueError:
                    return {
                        'valid': False,
                        'message': f'Invalid format for field: {field}'
                    }
            
            return {
                'valid': True,
                'message': 'Access inputs validation passed'
            }
            
        except Exception as e:
            return {
                'valid': False,
                'message': f'Input validation error: {str(e)}'
            }
    
    def _validate_identity_inputs(self, public_inputs: Dict[str, Any], 
                                challenge: str) -> Dict[str, Any]:
        """Validate identity verification inputs"""
        try:
            required_fields = ['identity_commitment', 'challenge', 'response_hash']
            
            # Check required fields
            for field in required_fields:
                if field not in public_inputs:
                    return {
                        'valid': False,
                        'message': f'Missing required field: {field}'
                    }
            
            # Validate challenge matches
            challenge_hash = int(hashlib.sha256(challenge.encode()).hexdigest(), 16) % (2**254)
            if str(challenge_hash) != public_inputs['challenge']:
                return {
                    'valid': False,
                    'message': 'Challenge mismatch'
                }
            
            # Validate field formats
            for field in required_fields:
                try:
                    int(public_inputs[field])
                except ValueError:
                    return {
                        'valid': False,
                        'message': f'Invalid format for field: {field}'
                    }
            
            return {
                'valid': True,
                'message': 'Identity inputs validation passed'
            }
            
        except Exception as e:
            return {
                'valid': False,
                'message': f'Input validation error: {str(e)}'
            }
    
    def _simulate_access_verification(self, proof: str, public_inputs: Dict[str, Any], 
                                    sample_id: str) -> Dict[str, Any]:
        """Simulate access permission proof verification"""
        # Basic validation
        validation_result = self._validate_access_inputs(public_inputs, sample_id)
        
        # Simulate proof verification (basic checks)
        proof_valid = (
            len(proof) == 64 and  # SHA256 hex length
            all(c in '0123456789abcdef' for c in proof.lower()) and
            validation_result['valid']
        )
        
        return {
            'success': True,
            'valid': proof_valid,
            'circuit_type': 'access_permission',
            'sample_id': sample_id,
            'verification_details': {
                'noir_verification': proof_valid,
                'input_validation': validation_result['valid'],
                'validation_message': validation_result.get('message', '')
            },
            'simulated': True
        }
    
    def _simulate_identity_verification(self, proof: str, public_inputs: Dict[str, Any], 
                                      challenge: str) -> Dict[str, Any]:
        """Simulate identity proof verification"""
        # Basic validation
        validation_result = self._validate_identity_inputs(public_inputs, challenge)
        
        # Simulate proof verification
        proof_valid = (
            len(proof) == 64 and  # SHA256 hex length
            all(c in '0123456789abcdef' for c in proof.lower()) and
            validation_result['valid']
        )
        
        return {
            'success': True,
            'valid': proof_valid,
            'circuit_type': 'identity_verification',
            'challenge': challenge,
            'verification_details': {
                'noir_verification': proof_valid,
                'input_validation': validation_result['valid'],
                'validation_message': validation_result.get('message', '')
            },
            'simulated': True
        }
    
    def batch_verify_proofs(self, proofs: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Verify multiple proofs in batch"""
        results = []
        
        for i, proof_data in enumerate(proofs):
            try:
                circuit_type = proof_data.get('circuit_type')
                
                if circuit_type == 'access_permission':
                    result = self.verify_access_permission_proof(
                        proof_data['proof'],
                        proof_data['public_inputs'],
                        proof_data['sample_id']
                    )
                elif circuit_type == 'identity_verification':
                    result = self.verify_identity_proof(
                        proof_data['proof'],
                        proof_data['public_inputs'],
                        proof_data['challenge']
                    )
                else:
                    result = {
                        'success': False,
                        'error': f'Unknown circuit type: {circuit_type}'
                    }
                
                result['proof_index'] = i
                results.append(result)
                
            except Exception as e:
                results.append({
                    'success': False,
                    'error': f'Batch verification error: {str(e)}',
                    'proof_index': i
                })
        
        # Calculate batch statistics
        successful_verifications = sum(1 for r in results if r.get('success', False))
        valid_proofs = sum(1 for r in results if r.get('valid', False))
        
        return {
            'success': True,
            'results': results,
            'statistics': {
                'total_proofs': len(proofs),
                'successful_verifications': successful_verifications,
                'valid_proofs': valid_proofs,
                'verification_rate': successful_verifications / len(proofs) if proofs else 0,
                'validity_rate': valid_proofs / len(proofs) if proofs else 0
            }
        }


